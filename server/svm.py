import pickle
import numpy as np
from sklearn.svm import SVC

class SVM:
    def __init__(self, SV, nSV, sv_coef, intercept, classes):
        self.SV = SV
        self.nSV = nSV
        self.sv_coef = sv_coef
        self.intercept = intercept
        self.classes = classes

    @staticmethod
    def from_pymodel(file):
        f = open(file, "r")
        skSVM = pickle.loads(f.read())
        return SVM(skSVM.support_vectors_, \
                skSVM.n_support_, \
                skSVM.dual_coef_, \
                skSVM._intercept_, \
                skSVM.classes_)

    # from a file's contents generated by java libsvm's svm.svm_save_model
    @staticmethod
    def from_javamodel(file):
        n_features = 784 # there doesn't seem to be an easy way to find this without reading the whole file
        f = open(file, "r")
        # current implementation only supports c_svc linear kernels
        assert f.readline().strip().split(" ") == ['svm_type', 'c_svc']
        assert f.readline().strip().split(" ") == ['kernel_type', 'linear']
        n_classes = int(f.readline().strip().split(" ")[1])
        n_support = int(f.readline().strip().split(" ")[1])
        intercept = np.array(map(float, f.readline().strip().split(" ")[1:]))
        classes = np.array(map(int, f.readline().strip().split(" ")[1:]))
        nSV = np.array(map(int, f.readline().strip().split(" ")[1:]))
        f.readline() # this line should just say 'SV'
        sv_coef = np.zeros((n_classes - 1, n_support), dtype=np.float64)
        SV = np.zeros((n_support, n_features))
        for i, line in enumerate(f):
            l = line.strip().split(" ")
            for j in range(n_classes - 1):
                sv_coef[j][i] = float(l[j])
            j += 1
            while j < len(l):
                index, value = l[j].split(":")
                SV[i][int(index)] = float(value)
                j += 1
        return SVM(SV, nSV, sv_coef, intercept, classes)

    def predict(self, X):
        nr_class = self.classes.shape[0]
        l = self.SV.shape[0]
        kvalue = np.zeros(l, dtype=np.float64)
        for i in range(l):
            kvalue[i] = X.dot(self.SV[i]) # kernel function for other kernel types

        start = np.zeros(nr_class, dtype=np.int32)
        start[0] = 0
        for i in range(1, nr_class):
            start[i] = start[i-1] + self.nSV[i-1]

        vote = np.zeros(nr_class, dtype=np.int32)

        p = 0
        for i in range(nr_class):
            for j in range(i+1, nr_class):
                sum = 0.0
                si = start[i]
                sj = start[j]
                ci = self.nSV[i]
                cj = self.nSV[j]

                coef1 = self.sv_coef[j-1]
                coef2 = self.sv_coef[i]
                for k in range(ci):
                    sum += coef1[si+k] * kvalue[si+k]
                for k in range(cj):
                    sum += coef2[sj+k] * kvalue[sj+k]
                sum -= self.intercept[p]
                if sum > 0:
                    vote[i] += 1
                else:
                    vote[j] += 1
                p += 1
        vote_max_idx = max([i for i in range(nr_class)], key=lambda x: vote[x])
        return self.classes[vote_max_idx]

def generate_model(training):
    d = np.loadtxt(open(training,"rb"),delimiter=",")
    x = np.delete(d, 0, 1)
    y = d[:,0]

    model = SVC(C=1e-6, kernel='linear')
    model.fit(x, y)
    return model

def get_custom_model(model):
    return SVM.from_pymodel(model)

if __name__ == "__main__":
    d = np.loadtxt(open("data/digit-dataset/data-test.csv", "rb"),delimiter=",")
    test_x = np.delete(d, 0, 1)
    test_y = d[:,0]
    # if False: # already saved to disk, not needed
    #     pymodel = get_digits_svm()
    #     print "Done training, trying to save to disk"
    #     s = pickle.dumps(pymodel)
    #     f = open("digits_svm.pkl", "w")
    #     f.write(s)
    # else:
    #     f = open("digits_svm.pkl", "r")
    #     pymodel = pickle.loads(f.read())
    # print "Converting to custom model and training"
    # model = get_custom_model(pymodel)
    # pyaccuracy = 0.0
    # modelaccuracy = 0.0
    # for i, x in enumerate(test_x):
    #     if pymodel.predict(x) == test_y[i]:
    #         pyaccuracy += 1.0 / len(test_y)
    #     if model.predict(x) == test_y[i]:
    #         modelaccuracy += 1.0 / len(test_y)
    # print pyaccuracy, modelaccuracy

    # model = SVM.from_javamodel("javalibsvm-digits.bin")
    f = open("digits_svm.pkl", "r")
    pymodel = pickle.loads(f.read())
    f.close()
    model = SVM.from_pymodel("digits_svm.pkl")
    javamodel = SVM.from_javamodel("./javalibsvm-digits.bin")
    model.predict(test_x[0])
